<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Interaktives Glücksrad</title>

  <style>
    body {
      text-align: center;
      padding: 20px;
      background: #ffffff;
      margin: 0;
      height: 100vh;
      overflow: hidden;
      color: #023d6b; /* Textfarbe für Layout-Kontrast, Typo kommt aus styles.css */
      font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
    }

    .logo-top-right {
      position: fixed;
      top: -10px;
      right: 80px;
      height: 120px;
      z-index: 1000;
    }

    .logo-top-left {
      position: fixed;
      top: 20px;
      left: 70px;
      height: 60px;
      z-index: 1000;
    }

    #wheelWrapper {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 40px; /* Abstand zwischen Rad und Button (falls genutzt) */
      margin-top: 10px;
    }

    #arrow {
      width: 0;
      height: 0;
      border-left: 15px solid transparent;
      border-right: 15px solid transparent;
      border-bottom: 25px solid #023d6b;
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
    }

    canvas {
      margin-top: 20px;
      border-radius: 12px;
    }

    /* Falls du einen Spin-Button nutzt */
    #spinBtn {
      padding: 12px 28px;
      height: 60px;
      min-width: 120px;
      font-size: 18px;
      margin-top: 10px;
      cursor: pointer;
      background: #023d6b;
      color: white;
      border: none;
      border-radius: 10px;
      transition: background-color 0.3s ease;
    }
    #spinBtn:hover {
      background-color: #013054;
    }

    /* Overlay-Container */
    #questions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 520px;
      max-width: 90vw;
      height: 90vh;
      background: #023d6b;
      box-shadow: 0 0 20px rgba(0,0,0,0.6);
      color: white;
      display: none; /* WICHTIG: nur einmal definiert; Anzeige steuert JS */
      z-index: 1000;
      flex-direction: column;
      overflow: hidden;
    }

    #imageContainer {
      background-color: #e0f2ff;
      flex: 1.2;
      min-height: 40%;
      display: flex;
      justify-content: center;
      align-items: center;
      padding-top: 2px;
      padding-bottom: 2px;
      overflow: hidden;
    }

    #imageContainer img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      display: block;
    }

    #questionsContent {
      background: #ffffff;
      flex: 3;
      overflow-y: auto;
      padding: 20px 30px 30px 30px;
      text-align: left;
      color: #000000; /* Fließtext im hellen Bereich */
    }

    #buttonRow {
      background: #ffffff;
      padding: 15px 30px;
      display: flex;
      justify-content: center;
      flex-shrink: 0;
    }
  </style>

  <link rel="stylesheet" href="styles.css">
</head>
<body>

  <div id="wheelWrapper">
    <div style="position: relative;">
      <div id="arrow"></div>
      <canvas id="wheelCanvas" width="700" height="700"></canvas>
    </div>

    <!-- (Optional) Spin-Button, wenn gewünscht
    <button id="spinBtn" aria-label="Glücksrad drehen">Drehen</button>
    -->
  </div>

  <div id="questions" tabindex="-1" role="dialog" aria-modal="true">
    <div id="imageContainer">
      <img id="resultImage" src="" alt="Ergebnisbild" />
    </div>
    <div id="questionsContent"></div>
    <div id="buttonRow">
      <button id="closeBtn" onclick="closeOverlay()">Schließen</button>
    </div>
  </div>

  <script>
    // Segment-Daten (unverändert; justification & Canvas-Text bleiben wie von dir)
    const segments = [
      // SDG 1
      {
        label: "Keine Armut (SDG 1)",
        color: "#e5243b",
        image: "https://www.fz-juelich.de/de/ueber-uns/mission/nachhaltigkeit/sdg-icon-de-01.svg/@@images/image-1-ed28193ef9c92d2942db408131a5aacb.svg",
        imageBgColor: "#e5243b",
        questions: [
          {
            text: "Frage: Wie trägt das Projekt OrganoRice zur Armutsbekämpfung bei?",
            answers: [
              { text: "A) Durch die Entwicklung gentechnisch veränderter Reissorten für den Export", correct: false },
              { text: "B) Durch Umstellung auf ökologischen Reisanbau mit Fokus auf Umweltverträglichkeit und ökonomische Perspektiven für Landwirte", correct: true },
              { text: "C) Durch staatlich finanzierte Reissubventionen ohne Veränderung der Anbaumethoden", correct: false }
            ],
            justification: "<a> https://www.fz-juelich.de/de/ibg/ibg-3/forschung/umweltprozesse-und-technologien/umweltsensorik-und-monitoring/organo-rice</a>OrganoRice (IBG-3) analysiert und begleitet die Umstellung von konventionellem auf ökologischen Reisanbau. Das Projekt berücksichtigt Pestizidreduktion, Wassermanagement, Reisqualität und sozioökonomische Rahmenbedingungen, um Landwirten eine nachhaltige und ökonomisch tragfähige Perspektive zu bieten, was wesentlich zur Armutsbekämpfung beiträgt."
          }
        ]
      }
    ];

    const canvas = document.getElementById("wheelCanvas");
    const ctx = canvas.getContext("2d");
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = 320;
    let lastIndex = -1;
    let spinning = false;
    let rotation = 0;

    const questionsOverlay = document.getElementById("questions");
    const resultImage = document.getElementById("resultImage");
    const questionsContent = document.getElementById("questionsContent");

    // Overlay beim Laden verstecken
    window.onload = () => {
      questionsOverlay.style.display = "none";
    };

    // Icons vorladen, dann Rad zeichnen
    let loadedImages = 0;
    const totalImages = segments.length;

    segments.forEach((segment) => {
      const img = new Image();
      img.src = segment.image;
      img.onload = () => {
        segment.iconImg = img;
        loadedImages++;
        if (loadedImages === totalImages) {
          drawWheel(-Math.PI / 2);
        }
      };
    });

    function drawWheel(rotationOffset = 0) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const numSegments = segments.length;
      const anglePerSegment = (2 * Math.PI) / numSegments;

      for (let i = 0; i < numSegments; i++) {
        const startAngle = i * anglePerSegment + rotationOffset;
        const endAngle = startAngle + anglePerSegment;

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
        ctx.fillStyle = segments[i].color;
        ctx.fill();

        const icon = segments[i].iconImg;
        if (icon) {
          const angle = startAngle + anglePerSegment / 2;

          const iconRadius = radius * 0.83;
          let iconX = centerX + iconRadius * Math.cos(angle);
          let iconY = centerY + iconRadius * Math.sin(angle);

          const offset = 4;
          iconX += Math.cos(angle) * offset;
          iconY += Math.sin(angle) * offset;

          const iconSize = 80;
          const r = 18;

          const x = iconX - iconSize / 2;
          const y = iconY - iconSize / 2;

          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.lineTo(x + iconSize - r, y);
          ctx.quadraticCurveTo(x + iconSize, y, x + iconSize, y + r);
          ctx.lineTo(x + iconSize, y + iconSize - r);
          ctx.quadraticCurveTo(x + iconSize, y + iconSize, x + iconSize - r, y + iconSize);
          ctx.lineTo(x + r, y + iconSize);
          ctx.quadraticCurveTo(x, y + iconSize, x, y + iconSize - r);
          ctx.lineTo(x, y + r);
          ctx.quadraticCurveTo(x, y, x + r, y);
          ctx.closePath();
          ctx.clip();

          ctx.drawImage(icon, x, y, iconSize, iconSize);
          ctx.restore();
        }
      }
    }

    drawWheel();

    // Klick auf Canvas startet Spin
    canvas.addEventListener("click", () => {
      if (spinning) return;
      startSpin();
    });

    function startSpin() {
      spinning = true;
      resultImage.src = "";

      let spinAngle = Math.random() * 10 + 20;
      let currentRotation = 0;
      const spinDuration = 3000;
      const startTime = performance.now();

      function animate(time) {
        const elapsed = time - startTime;
        if (elapsed < spinDuration) {
          const easeOut = 1 - Math.pow(1 - elapsed / spinDuration, 3);
          currentRotation = spinAngle * easeOut * 2 * Math.PI;
          drawWheel(currentRotation);
          requestAnimationFrame(animate);
        } else {
          rotation = currentRotation % (2 * Math.PI);
          drawWheel(rotation);
          spinning = false;

          const numSegments = segments.length;
          const anglePerSegment = (2 * Math.PI) / numSegments;
          let selectedIndex = Math.floor(((2 * Math.PI) - rotation + anglePerSegment / 2) / anglePerSegment) % numSegments;
          if (selectedIndex === lastIndex) {
            selectedIndex = (selectedIndex + 1) % numSegments;
          }

          lastIndex = selectedIndex;
          showResult(selectedIndex);
        }
      }

      requestAnimationFrame(animate);
    }

    function handleKeydown(e, segIdx, qIdx) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        toggleAnswers(segIdx, qIdx);
      }
    }

    function showResult(index) {
      const segment = segments[index];
      const tempImg = new Image();
      tempImg.onload = () => {
        resultImage.src = tempImg.src;
      };
      tempImg.src = segment.image;

      document.getElementById("imageContainer").style.backgroundColor = segment.imageBgColor || "#e0f2ff";

      let html = `<strong>${segment.label}</strong>`;

      segment.questions.forEach((q, i) => {
        html += `<div 
          class="questionToggle" 
          role="button" 
          tabindex="0" 
          onclick="toggleAnswers(${index},${i})" 
          onkeydown="handleKeydown(event, ${index}, ${i})">
          ${q.text}
        </div>`;

        html += `<div class="answersWrapper" id="answers-${index}-${i}">`;
        q.answers.forEach((a, ai) => {
          const id = `answer-${index}-${i}-${ai}`;
          html += `<button class="answer" id="${id}" onclick="checkAnswer('${id}', ${a.correct})" type="button">${a.text}</button>`;
        });
        html += `</div>`;
      });

      questionsContent.innerHTML = html;
      questionsOverlay.style.display = "flex";
      questionsOverlay.focus();

      setTimeout(() => {
        const firstAnswer = document.querySelector(`#answers-${index}-0 .answer`);
        if (firstAnswer) firstAnswer.focus();
      }, 50);
    }

    function toggleAnswers(segIdx, qIdx) {
      const elem = document.getElementById(`answers-${segIdx}-${qIdx}`);
      if (!elem) return;
      elem.style.display = elem.style.display === "block" ? "none" : "block";
    }

    function checkAnswer(id, isCorrect) {
      const el = document.getElementById(id);
      if (!el || el.classList.contains("correct") || el.classList.contains("incorrect")) return;

      if (isCorrect) {
        el.classList.add("correct");

        const [_, segIdx, qIdx, ai] = id.split("-");
        const question = segments[segIdx].questions[qIdx];
        if (question.justification) {
          const justificationElem = document.createElement("div");
          justificationElem.style.marginTop = "10px";
          justificationElem.style.padding = "10px";
          justificationElem.style.backgroundColor = "#e6f6ec";
          justificationElem.style.borderLeft = "4px solid #28a745";
          justificationElem.style.color = "#000";
          justificationElem.innerHTML = ` ${question.justification}`;

          el.insertAdjacentElement("afterend", justificationElem);
        }
      } else {
        el.classList.add("incorrect");
      }
    }

    function closeOverlay() {
      questionsOverlay.style.display = "none";
      drawWheel(-Math.PI / 2);
    }

    document.addEventListener("keydown", function (e) {
      if (e.key === "Escape" && questionsOverlay.style.display === "flex") {
        closeOverlay();
      }
    });
  </script>
</body>
</html>
